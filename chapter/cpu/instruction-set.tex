%!TEX root = ../../gbctr.tex
%!TEX program = xelatex
\providecommand{\main}{../..}
\documentclass[\main/gbctr.tex]{subfiles}
\begin{document}

\chapter{Sharp SM83 instruction set}

\section{8-bit load instructions}

8-bit load instructions transfer one byte of data between two 8-bit registers,
or between one 8-bit register and location in memory.

\subsection{LD r, r': Load register (register)}
\label{inst:LD_r_r}

Load to the 8-bit register \texttt{r}, data from the 8-bit register \texttt{r'}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{01xxxyyy}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{LD r, r'} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: LD B, C
if opcode == 0x41:
  B = C
\end{verbatim}
\end{description}

\subsection{LD r, n: Load register (immediate)}
\label{inst:LD_r_n}

Load to the 8-bit register \texttt{r}, the immediate data \texttt{n}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00xxx110}/various + \texttt{n}
  \item[Length]
    2 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD r, n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} ; [opacity=0.4] 8D{PC+2} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: LD B, n
if opcode == 0x06:
  B = read(PC++)
\end{verbatim}
\end{description}

\subsection{LD r, (HL): Load register (indirect HL)}
\label{inst:LD_r_hl}

Load to the 8-bit register \texttt{r}, data from the absolute address specified by the 16-bit register HL.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{01xxx110}/various
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD r, (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: LD B, (HL)
if opcode == 0x46:
  B = read(HL)
\end{verbatim}
\end{description}

\subsection{LD (HL), r: Load from register (indirect HL)}
\label{inst:LD_hl_r}

Load to the absolute address specified by the 16-bit register HL, data from the 8-bit register \texttt{r}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{01110xxx}/various
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD (HL), r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: LD (HL), B
if opcode == 0x70:
  write(HL, B)
\end{verbatim}
\end{description}

\subsection{LD (HL), n: Load from immediate data (indirect HL)}
\label{inst:LD_hl_n}

Load to the absolute address specified by the 16-bit register HL, the immediate data \texttt{n}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00110110}/\hex{36} + \texttt{n}
  \item[Length]
    2 bytes
  \item[Duration]
    3 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{LD (HL), n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n} 8D{W: n} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{HL} ; [opacity=0.4] 8D{PC+2} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x36:
  n = read(PC++)
  write(HL, n)
\end{verbatim}
\end{description}

\subsection{LD A, (BC): Load accumulator (indirect BC)}
\label{inst:LD_a_bc}

Load to the 8-bit A register, data from the absolute address specified by the 16-bit register BC.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00001010}/\hex{0A}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD A, (BC)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{BC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x0A:
  A = read(BC)
\end{verbatim}
\end{description}

\subsection{LD A, (DE): Load accumulator (indirect DE)}
\label{inst:LD_a_de}

Load to the 8-bit A register, data from the absolute address specified by the 16-bit register DE.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00011010}/\hex{1A}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD A, (DE)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{DE} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x1A:
  A = read(DE)
\end{verbatim}
\end{description}

\subsection{LD (BC), A: Load from accumulator (indirect BC)}
\label{inst:LD_bc_a}

Load to the absolute address specified by the 16-bit register BC, data from the 8-bit A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00000010}/\hex{02}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD (BC), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{BC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x02:
  write(BC, A)
\end{verbatim}
\end{description}

\subsection{LD (DE), A: Load from accumulator (indirect DE)}
\label{inst:LD_de_a}

Load to the absolute address specified by the 16-bit register DE, data from the 8-bit A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00010010}/\hex{12}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD (DE), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{DE} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x12:
  write(DE, A)
\end{verbatim}
\end{description}

\subsection{LD A, (nn): Load accumulator (direct)}
\label{inst:LD_a_nn}

Load to the 8-bit A register, data from the absolute address specified by the 16-bit operand \texttt{nn}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11111010}/\hex{FA} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{LD A, (nn)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8D{R: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8D{nn} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xFA:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  A = read(nn)
\end{verbatim}
\end{description}

\subsection{LD (nn), A: Load from accumulator (direct)}
\label{inst:LD_nn_a}

Load to the absolute address specified by the 16-bit operand \texttt{nn}, data from the 8-bit A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11101010}/\hex{EA} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{LD (nn), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8D{W: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8D{nn} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xEA:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  write(nn, A)
\end{verbatim}
\end{description}

\subsection{LDH A, (C): Load accumulator (indirect \hex{FF00}+C)}
\label{inst:LDH_a_c}

Load to the 8-bit A register, data from the address specified by the 8-bit C
register. The full 16-bit absolute address is obtained by setting the most
significant byte to \hex{FF} and the least significant byte to the value of C,
so the possible range is \hexrange{FF00}{FFFF}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11110010}/\hex{F2}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LDH A, (C)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{\hex{FF00}+C} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xF2:
  A = read(unsigned_16(lsb=C, msb=0xFF))
\end{verbatim}
\end{description}

\subsection{LDH (C), A: Load from accumulator (indirect \hex{FF00}+C)}
\label{inst:LDH_c_a}

Load to the address specified by the 8-bit C register, data from the 8-bit A
register. The full 16-bit absolute address is obtained by setting the most
significant byte to \hex{FF} and the least significant byte to the value of C,
so the possible range is \hexrange{FF00}{FFFF}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11100010}/\hex{E2}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LDH (C), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{\hex{FF00}+C} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xE2:
  write(unsigned_16(lsb=C, msb=0xFF), A)
\end{verbatim}
\end{description}

\subsection{LDH A, (n): Load accumulator (direct \hex{FF00}+n)}
\label{inst:LDH_a_n}

Load to the 8-bit A register, data from the address specified by the 8-bit
immediate data \texttt{n}. The full 16-bit absolute address is obtained by
setting the most significant byte to \hex{FF} and the least significant byte to
the value of \texttt{n}, so the possible range is \hexrange{FF00}{FFFF}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11110000}/\hex{F0}
  \item[Length]
    2 bytes
  \item[Duration]
    3 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{LD A, (C)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n} 8D{R: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{\hex{FF00}+n} ; [opacity=0.4] 8D{PC+2} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xF0:
  n = read(PC++)
  A = read(unsigned_16(lsb=n, msb=0xFF))
\end{verbatim}
\end{description}

\subsection{LDH (n), A: Load from accumulator (direct \hex{FF00}+n)}
\label{inst:LDH_n_a}

Load to the address specified by the 8-bit immediate data \texttt{n}, data from
the 8-bit A register. The full 16-bit absolute address is obtained by setting
the most significant byte to \hex{FF} and the least significant byte to the
value of \texttt{n}, so the possible range is \hexrange{FF00}{FFFF}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11100000}/\hex{E0}
  \item[Length]
    2 bytes
  \item[Duration]
    3 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{LDH (n), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n} 8D{W: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{\hex{FF00}+n} ; [opacity=0.4] 8D{PC+2} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xE0:
  n = read(PC++)
  write(unsigned_16(lsb=n, msb=0xFF), A)
\end{verbatim}
\end{description}

\subsection{LD A, (HL-): Load accumulator (indirect HL, decrement)}
\label{inst:LD_a_hld}

Load to the 8-bit A register, data from the absolute address specified by the
16-bit register HL. The value of HL is decremented after the memory read.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00111010}/\hex{3A}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD A, (HL-)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x3A:
  A = read(HL--)
\end{verbatim}
\end{description}

\subsection{LD (HL-), A: Load from accumulator (indirect HL, decrement)}
\label{inst:LD_hld_a}

Load to the absolute address specified by the 16-bit register HL, data from the
8-bit A register. The value of HL is decremented after the memory write.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00110010}/\hex{32}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD (HL-), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x32:
  write(HL--, A)
\end{verbatim}
\end{description}

\subsection{LD A, (HL+): Load accumulator (indirect HL, increment)}
\label{inst:LD_a_hli}

Load to the 8-bit A register, data from the absolute address specified by the
16-bit register HL. The value of HL is incremented after the memory read.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00101010}/\hex{2A}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD A, (HL+)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x2A:
  A = read(HL++)
\end{verbatim}
\end{description}

\subsection{LD (HL+), A: Load from accumulator (indirect HL, increment)}
\label{inst:LD_hli_a}

Load to the absolute address specified by the 16-bit register HL, data from the
8-bit A register. The value of HL is incremented after the memory write.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00100010}/\hex{22}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD (HL+), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x22:
  write(HL++, A)
\end{verbatim}
\end{description}

\section{16-bit load instructions}

16-bit load instructions transfer two bytes of data between two 16-bit
registers, or between one 16-bit register and two sequential locations in
memory.

\subsection{LD rr, nn: Load 16-bit register / register pair}
\label{inst:LD_rr_nn}

Load to the 16-bit register \texttt{rr}, the immediate 16-bit data \texttt{nn}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00xx0001}/various + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 byte
  \item[Duration]
    3 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{LD rr, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: LD BC, nn
if opcode == 0x01:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  BC = nn
\end{verbatim}
\end{description}

\subsection{LD (nn), SP: Load from stack pointer (direct)}
\label{inst:LD_nn_sp}

Load to the absolute address specified by the 16-bit operand \texttt{nn}, data from the 16-bit SP register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00001000}/\hex{08} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 byte
  \item[Duration]
    5 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5} 8D{M6/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 40D{LD (nn), SP} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8D{W: lsb(SP)} 8D{W: msb(SP)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8D{nn} 8D{nn+1} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x08:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  write(nn, lsb(SP))
  write(nn+1, msb(SP))
\end{verbatim}
\end{description}

\subsection{LD SP, HL: Load stack pointer from HL}
\label{inst:LD_sp_hl}

Load to the 16-bit SP register, data from the 16-bit HL register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11111001}/\hex{F9}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD SP, HL} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8U ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xF9:
  SP = HL
\end{verbatim}
\end{description}

\subsection{PUSH rr: Push to stack}
\label{inst:PUSH_rr}

Push to the stack memory, data from the 16-bit register \texttt{rr}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11xx0101}/various
  \item[Length]
    1 byte
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{PUSH rr} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U 8D{W: msb(rr)} 8D{W: lsb(rr)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP-1} 8D{SP-2} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: PUSH BC
if opcode == 0xC5:
  SP--
  write(SP--, msb(BC))
  write(SP, lsb(BC))
\end{verbatim}
\end{description}

\subsection{POP rr: Pop from stack}
\label{inst:POP_rr}

Pops to the 16-bit register \texttt{rr}, data from the stack memory.

This instruction does not do calculations that affect flags, but POP AF
completely replaces the F register value, so all flags are changed based on the
8-bit data that is read from memory.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11xx0001}/various
  \item[Length]
    1 byte
  \item[Duration]
    3 machine cycles
  \item[Flags]
    see the instruction description
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{POP rr} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(rr)} 8D{R: msb(rr)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP+1} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: POP BC
if opcode == 0xC1:
  BC = unsigned_16(lsb=read(SP++), msb=read(SP++))
\end{verbatim}
\end{description}

\section{8-bit arithmetic and logical instructions}

\subsection{ADD r: Add (register)}
\label{inst:ADD_r}

Adds to the 8-bit A register, the 8-bit register \texttt{r}, and stores the
result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10000xxx}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, N = 0, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{ADD r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: ADD B
if opcode == 0x80:
  result, carry_per_bit = A + B
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{ADD (HL): Add (indirect HL)}
\label{inst:ADD_hl}

Adds to the 8-bit A register, data from the absolute address specified by the
16-bit register HL, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10000110}/\hex{86}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 0, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{ADD (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x86:
  data = read(HL)
  result, carry_per_bit = A + data
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{ADD n: Add (immediate)}
\label{inst:ADD_n}

Adds to the 8-bit A register, the immediate data \texttt{n}, and stores the
result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11000110}/\hex{C6} + \texttt{n}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 0, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{ADD n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xC6:
  n = read(PC++)
  result, carry_per_bit = A + n
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{ADC r: Add with carry (register)}
\label{inst:ADC_r}

Adds to the 8-bit A register, the carry flag and the 8-bit register \texttt{r},
and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10001xxx}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, N = 0, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{ADC r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: ADC B
if opcode == 0x88:
  result, carry_per_bit = A + flags.C + B
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{ADC (HL): Add with carry (indirect HL)}
\label{inst:ADC_hl}

Adds to the 8-bit A register, the carry flag and data from the absolute address
specified by the 16-bit register HL, and stores the result back into the A
register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10001110}/\hex{8E}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 0, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{ADC (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x8E:
  data = read(HL)
  result, carry_per_bit = A + flags.C + data
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{ADC n: Add with carry (immediate)}
\label{inst:ADC_n}

Adds to the 8-bit A register, the carry flag and the immediate data \texttt{n},
and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11001110}/\hex{CE} + \texttt{n}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 0, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{ADC n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xCE:
  n = read(PC++)
  result, carry_per_bit = A + flags.C + n
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{SUB r: Subtract (register)}
\label{inst:SUB_r}

Subtracts from the 8-bit A register, the 8-bit register \texttt{r}, and stores
the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10010xxx}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, N = 1, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{SUB r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: SUB B
if opcode == 0x90:
  result, carry_per_bit = A - B
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 1
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{SUB (HL): Subtract (indirect HL)}
\label{inst:SUB_hl}

Subtracts from the 8-bit A register, data from the absolute address specified
by the 16-bit register HL, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10010110}/\hex{96}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 1, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{SUB (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x96:
  data = read(HL)
  result, carry_per_bit = A - data
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 1
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{SUB n: Subtract (immediate)}
\label{inst:SUB_n}

Subtracts from the 8-bit A register, the immediate data \texttt{n}, and stores
the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11010110}/\hex{D6} + \texttt{n}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 1, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{SUB n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xD6:
  n = read(PC++)
  result, carry_per_bit = A - n
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 1
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{SBC r: Subtract with carry (register)}
\label{inst:SBC_r}

Subtracts from the 8-bit A register, the carry flag and the 8-bit register
\texttt{r}, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10011xxx}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, N = 1, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{SBC r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: SBC B
if opcode == 0x98:
  result, carry_per_bit = A - flags.C - B
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 1
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{SBC (HL): Subtract with carry (indirect HL)}
\label{inst:SBC_hl}

Subtracts from the 8-bit A register, the carry flag and data from the absolute
address specified by the 16-bit register HL, and stores the result back into
the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10011110}/\hex{9E}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 1, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{SBC (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x9E:
  data = read(HL)
  result, carry_per_bit = A - flags.C - data
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 1
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{SBC n: Subtract with carry (immediate)}
\label{inst:SBC_n}

Subtracts from the 8-bit A register, the carry flag and the immediate data
\texttt{n}, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11011110}/\hex{DE} + \texttt{n}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 1, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{SBC n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xDE:
  n = read(PC++)
  result, carry_per_bit = A - flags.C - n
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 1
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{CP r: Compare (register)}
\label{inst:CP_r}

Subtracts from the 8-bit A register, the 8-bit register \texttt{r}, and updates
flags based on the result. This instruction is basically identical to
\hyperref[inst:SUB_r]{SUB r}, but does not update the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10111xxx}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, N = 1, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{CP r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: CP B
if opcode == 0xB8:
  result, carry_per_bit = A - B
  flags.Z = 1 if result == 0 else 0
  flags.N = 1
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{CP (HL): Compare (indirect HL)}
\label{inst:CP_hl}

Subtracts from the 8-bit A register, data from the absolute address specified
by the 16-bit register HL, and updates flags based on the result. This
instruction is basically identical to \hyperref[inst:SUB_hl]{SUB (HL)}, but
does not update the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10111110}/\hex{BE}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 1, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{CP (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xBE:
  data = read(HL)
  result, carry_per_bit = A - data
  flags.Z = 1 if result == 0 else 0
  flags.N = 1
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{CP n: Compare (immediate)}
\label{inst:CP_n}

Subtracts from the 8-bit A register, the immediate data \texttt{n}, and updates
flags based on the result. This instruction is basically identical to
\hyperref[inst:SUB_n]{SUB n}, but does not update the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11111110}/\hex{FE} + \texttt{n}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 1, H = \faStar, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{CP n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xFE:
  n = read(PC++)
  result, carry_per_bit = A - n
  flags.Z = 1 if result == 0 else 0
  flags.N = 1
  flags.H = 1 if carry_per_bit[3] else 0
  flags.C = 1 if carry_per_bit[7] else 0
\end{verbatim}
\end{description}

\subsection{INC r: Increment (register)}
\label{inst:INC_r}

Increments data in the 8-bit register \texttt{r}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00xxx100}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, N = 0, H = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{INC r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: INC B
if opcode == 0x04:
  result, carry_per_bit = B + 1
  B = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 1 if carry_per_bit[3] else 0
\end{verbatim}
\end{description}

\subsection{INC (HL): Increment (indirect HL)}
\label{inst:INC_hl}

Increments data at the absolute address specified by the 16-bit register HL.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00110100}/\hex{34}
  \item[Length]
    1 byte
  \item[Duration]
    3 machine cycles
  \item[Flags]
    Z = \faStar, N = 0, H = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{INC (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data} 8D{W: data}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} 8D{HL}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x34:
  data = read(HL)
  result, carry_per_bit = data + 1
  write(HL, result)
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 1 if carry_per_bit[3] else 0
\end{verbatim}
\end{description}

\subsection{DEC r: Decrement (register)}
\label{inst:DEC_r}

Decrements data in the 8-bit register \texttt{r}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00xxx101}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, N = 1, H = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{DEC r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: DEC B
if opcode == 0x05:
  result, carry_per_bit = B - 1
  B = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 1
  flags.H = 1 if carry_per_bit[3] else 0
\end{verbatim}
\end{description}

\subsection{DEC (HL): Decrement (indirect HL)}
\label{inst:DEC_hl}

Decrements data at the absolute address specified by the 16-bit register HL.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00110101}/\hex{35}
  \item[Length]
    1 byte
  \item[Duration]
    3 machine cycles
  \item[Flags]
    Z = \faStar, N = 1, H = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{DEC (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data} 8D{W: data}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} 8D{HL}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x35:
  data = read(HL)
  result, carry_per_bit = data - 1
  write(HL, result)
  flags.Z = 1 if result == 0 else 0
  flags.N = 1
  flags.H = 1 if carry_per_bit[3] else 0
\end{verbatim}
\end{description}

\subsection{AND r: Bitwise AND (register)}
\label{inst:AND_r}

Performs a bitwise AND operation between the 8-bit A register and the 8-bit register \texttt{r}, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10100xxx}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, N = 0, H = 1, C = 0
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{AND r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: AND B
if opcode == 0xA0:
  result = A & B
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 1
  flags.C = 0
\end{verbatim}
\end{description}

\subsection{AND (HL): Bitwise AND (indirect HL)}
\label{inst:AND_hl}

Performs a bitwise AND operation between the 8-bit A register and data from the absolute address specified by the 16-bit register HL, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10100110}/\hex{A6}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 0, H = 1, C = 0
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{AND (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xA6:
  data = read(HL)
  result = A & data
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 1
  flags.C = 0
\end{verbatim}
\end{description}

\subsection{AND n: Bitwise AND (immediate)}
\label{inst:AND_n}

Performs a bitwise AND operation between the 8-bit A register and immediate data \texttt{n}, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11100110}/\hex{E6} + \texttt{n}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 0, H = 1, C = 0
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{AND n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xE6:
  n = read(PC++)
  result = A & n
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 1
  flags.C = 0
\end{verbatim}
\end{description}

\subsection{OR r: Bitwise OR (register)}
\label{inst:OR_r}

Performs a bitwise OR operation between the 8-bit A register and the 8-bit register \texttt{r}, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10110xxx}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, N = 0, H = 0, C = 0
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{OR r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: OR B
if opcode == 0xB0:
  result = A | B
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 0
  flags.C = 0
\end{verbatim}
\end{description}

\subsection{OR (HL): Bitwise OR (indirect HL)}
\label{inst:OR_hl}

Performs a bitwise OR operation between the 8-bit A register and data from the absolute address specified by the 16-bit register HL, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10110110}/\hex{B6}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 0, H = 0, C = 0
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{OR (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xB6:
  data = read(HL)
  result = A | data
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 0
  flags.C = 0
\end{verbatim}
\end{description}

\subsection{OR n: Bitwise OR (immediate)}
\label{inst:OR_n}

Performs a bitwise OR operation between the 8-bit A register and immediate data \texttt{n}, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11110110}/\hex{F6} + \texttt{n}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 0, H = 0, C = 0
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{OR n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xF6:
  n = read(PC++)
  result = A | n
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 0
  flags.C = 0
\end{verbatim}
\end{description}

\subsection{XOR r: Bitwise XOR (register)}
\label{inst:XOR_r}

Performs a bitwise XOR operation between the 8-bit A register and the 8-bit register \texttt{r}, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10101xxx}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, N = 0, H = 0, C = 0
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{XOR r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: XOR B
if opcode == 0xB8:
  result = A ^ B
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 0
  flags.C = 0
\end{verbatim}
\end{description}

\subsection{XOR (HL): Bitwise XOR (indirect HL)}
\label{inst:XOR_hl}

Performs a bitwise XOR operation between the 8-bit A register and data from the absolute address specified by the 16-bit register HL, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{10101110}/\hex{BE}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 0, H = 0, C = 0
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{XOR (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xBE:
  data = read(HL)
  result = A ^ data
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 0
  flags.C = 0
\end{verbatim}
\end{description}

\subsection{XOR n: Bitwise XOR (immediate)}
\label{inst:XOR_n}

Performs a bitwise XOR operation between the 8-bit A register and immediate data \texttt{n}, and stores the result back into the A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11101110}/\hex{EE} + \texttt{n}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    Z = \faStar, N = 0, H = 0, C = 0
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{XOR n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1}; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xEE:
  n = read(PC++)
  result = A ^ n
  A = result
  flags.Z = 1 if result == 0 else 0
  flags.N = 0
  flags.H = 0
  flags.C = 0
\end{verbatim}
\end{description}

\subsection{CCF: Complement carry flag}
\label{inst:CCF}

Flips the carry flag, and clears the N and H flags.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00111111}/\hex{3F}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    N = 0, H = 0, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{CCF} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x3F:
  flags.N = 0
  flags.H = 0
  flags.C = ~flags.C
\end{verbatim}
\end{description}

\subsection{SCF: Set carry flag}
\label{inst:SCF}

Sets the carry flag, and clears the N and H flags.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00110111}/\hex{37}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    N = 0, H = 0, C = 1
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{SCF} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x37:
  flags.N = 0
  flags.H = 0
  flags.C = 1
\end{verbatim}
\end{description}

\subsection{DAA: Decimal adjust accumulator}
\label{inst:DAA}

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00100111}/\hex{27}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, H = 0, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{DAA} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\end{description}

\subsection{CPL: Complement accumulator}
\label{inst:CPL}

Flips all the bits in the 8-bit A register, and sets the N and H flags.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00101111}/\hex{2F}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    N = 1, H = 1
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{CPL} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x2F:
  A = ~A
  flags.N = 1
  flags.H = 1
\end{verbatim}
\end{description}

\section{16-bit arithmetic instructions}

\section{Rotate, shift, and bit operation instructions}

\section{Control flow instructions}

\subsection{JP nn: Jump}
\label{inst:JP}

Unconditional jump to the absolute address specified by the 16-bit operand \texttt{nn}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{11000011}/\hex{C3} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{JP nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8U ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xC3:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  PC = nn
\end{verbatim}
\end{description}

\subsection{JP HL: Jump to HL}
\label{inst:JP_hl}

Unconditional jump to the absolute address specified by the 16-bit register HL.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11101001}/\hex{E9}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{JP HL} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{HL} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xE9:
  PC = HL
\end{verbatim}
\end{description}

\begin{warning}
  In some documentation this instruction is written as \texttt{JP [HL]}. This
  is very misleading, since brackets are usually used to indicate a memory
  read, and this instruction simply copies the value of HL to PC.
\end{warning}

\subsection{JP cc, nn: Jump (conditional)}
\label{inst:JP_cc}

Conditional jump to the absolute address specified by the 16-bit operand \texttt{nn}, depending on the condition \texttt{cc}.

Note that the operand (absolute address) is read even when the condition is false!

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{110cc010}/various + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    3 machine cycles (cc=false), or 4 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{JP cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{JP cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8U ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC2, 0xD2, 0xCA, 0xDA]:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  if F.check_condition(cc):
    PC = nn
\end{verbatim}
\end{description}

\subsection{JR e: Relative jump}
\label{inst:JR}

Unconditional jump to the relative address specified by the signed 8-bit operand \texttt{e}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{00011000}/\hex{18} + offset \texttt{e}
  \item[Length]
    2 bytes
  \item[Duration]
    3 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{JR e} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: e} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8U ; [opacity=0.4] 8D{PC+2+e} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x18:
  e = signed_8(read(PC++))
  PC = PC + e
\end{verbatim}
\end{description}

\subsection{JR cc, e: Relative jump (conditional)}
\label{inst:JR_cc}

Conditional jump to the relative address specified by the signed 8-bit operand \texttt{e}, depending on the condition \texttt{cc}.

Note that the operand (relative address offset) is read even when the condition is false!

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{001cc000}/various + offset \texttt{e}
  \item[Length]
    2 bytes
  \item[Duration]
    2 machine cycles (cc=false), or 3 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{JR cc, e} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: e} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1}; [opacity=0.4] 8D{PC+2} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{JR cc, e} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: e} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8U ; [opacity=0.4] 8D{PC+2+e} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0x20, 0x30, 0x28, 0x38]:
  e = signed_8(read(PC++))
  if F.check_condition(cc):
    PC = PC + e
\end{verbatim}
\end{description}

\subsection{CALL nn: Call function}
\label{inst:CALL}

Unconditional function call to the absolute address specified by the 16-bit operand \texttt{nn}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{11001101}/\hex{CD} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    6 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5} 8D{M6} 8D{M7/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 48D{CALL nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U 8D{W: msb(PC+3)} 8D{W: lsb(PC+3)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8D{SP} 8D{SP-1} 8D{SP-2} ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xCD:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  SP--
  write(SP--, msb(PC))
  write(SP, lsb(PC))
  PC = nn
\end{verbatim}
\end{description}

\subsection{CALL cc, nn: Call function (conditional)}
\label{inst:CALL_cc}

Conditional function call to the absolute address specified by the 16-bit operand \texttt{nn}, depending on the condition \texttt{cc}.

Note that the operand (absolute address) is read even when the condition is false!

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{110cc100}/various + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    3 machine cycles (cc=false), or 6 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{CALL cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5} 8D{M6} 8D{M7/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 48D{CALL cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U 8D{W: msb(PC+3)} 8D{W: lsb(PC+3)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8D{SP} 8D{SP-1} 8D{SP-2} ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC4, 0xD4, 0xCC, 0xDC]:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  if F.check_condition(cc):
    SP--
    write(SP--, msb(PC))
    write(SP, lsb(PC))
    PC = nn
\end{verbatim}
\end{description}

\subsection{RET: Return from function}
\label{inst:RET}

Unconditional return from a function.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11001001}/\hex{C9}
  \item[Length]
    1 byte
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{RET} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(PC)} 8D{R: msb(PC)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP+1} 8U ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xC9:
  PC = unsigned_16(lsb=read(SP++), msb=read(SP++))
\end{verbatim}
\end{description}

\subsection{RET cc: Return from function (conditional)}
\label{inst:RET_cc}

Conditional return from a function, depending on the condition \texttt{cc}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{110cc000}/various
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles (cc=false), or 5 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{RET cc} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8U ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5} 8D{M6/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 40D{RET cc} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U 8D{R: lsb(PC)} 8D{R: msb(PC)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8U 8D{SP} 8D{SP+1} 8U ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC0, 0xD0, 0xC8, 0xD8]:
  if F.check_condition(cc):
    PC = unsigned_16(lsb=read(SP++), msb=read(SP++))
\end{verbatim}
\end{description}

\subsection{RETI: Return from interrupt handler}
\label{inst:RETI}

Unconditional return from a function. Also enables interrupts by setting IME=1.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11011001}/\hex{D9}
  \item[Length]
    1 byte
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{RETI} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(PC)} 8D{R: msb(PC)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP+1} 8U ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xD9:
  PC = unsigned_16(lsb=read(SP++), msb=read(SP++))
  IME = 1
\end{verbatim}
\end{description}

\subsection{RST n: Restart / Call function (implied)}
\label{inst:RST}

Unconditional function call to the absolute fixed address defined by the opcode.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11xxx111}/various
  \item[Length]
    1 byte
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{RST n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U 8D{W: msb(PC+1)} 8D{W: lsb(PC+1)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP-1} 8D{SP-2} ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC7, 0xD7, 0xE7, 0xF7, 0xCF, 0xDF, 0xEF, 0xFF]:
  n = rst_address(opcode)
  SP--
  write(SP--, msb(PC))
  write(SP, lsb(PC))
  PC = unsigned_16(lsb=n, msb=0x00)
\end{verbatim}
\end{description}

\section{Miscellaneous instructions}

\subsection{HALT: Halt system clock}
\label{inst:HALT}

\subsection{STOP: Stop system and main clocks}
\label{inst:STOP}

\subsection{DI: Disable interrupts}
\label{inst:DI}

Disables interrupt handling by setting IME=0 and cancelling any scheduled
effects of the EI instruction if any.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11110011}/\hex{F3}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{DI} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xF3:
  IME = 0
\end{verbatim}
\end{description}

\subsection{EI: Enable interrupts}
\label{inst:EI}

Schedules interrupt handling to be enabled after the next machine cycle.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11111011}/\hex{FB}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle (+ 1 machine cycle for the effect)
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{EI} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xFB:
  IME_scheduled = true
\end{verbatim}
\end{description}

\subsection{NOP: No operation}
\label{inst:NOP}

No operation. This instruction doesn't do anything, but can be used to add a
delay of one machine cycle and increment PC by one.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00000000}/\hex{00}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{NOP} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x00:
  // nothing
\end{verbatim}
\end{description}

\end{document}
