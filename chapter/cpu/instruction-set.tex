%!TEX root = ../../gbctr.tex
%!TEX program = xelatex
\providecommand{\main}{../..}
\documentclass[\main/gbctr.tex]{subfiles}
\begin{document}

\chapter{Sharp SM83 instruction set}

\section{8-bit load instructions}

8-bit load instructions transfer one byte of data between two 8-bit registers,
or between one 8-bit register and location in memory.

\subsection{LD r, r'}
\label{inst:LD_r_r}

Load to the 8-bit register \texttt{r}, data from the 8-bit register \texttt{r'}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{01xxxyyy}/various
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{LD r, r'} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode}; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: LD B, C
if opcode == 0x41:
  B = C
\end{verbatim}
\end{description}

\subsection{LD r, n}
\label{inst:LD_r_n}

Load to the 8-bit register \texttt{r}, the immediate data \texttt{n}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00xxx110}/various + \texttt{n}
  \item[Length]
    2 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD r, n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} ; [opacity=0.4] 8D{PC+2} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: LD B, n
if opcode == 0x06:
  B = read(PC++)
\end{verbatim}
\end{description}

\subsection{LD r, (HL)}
\label{inst:LD_r_hl}

Load to the 8-bit register \texttt{r}, data from the absolute address specified by the 16-bit register HL.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{01xxx110}/various
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD r, (HL)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: LD B, (HL)
if opcode == 0x46:
  B = read(HL)
\end{verbatim}
\end{description}

\subsection{LD (HL), r}
\label{inst:LD_hl_r}

Load to the absolute address specified by the 16-bit register HL, data from the 8-bit register \texttt{r}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{01110xxx}/various
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD (HL), r} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: LD (HL), B
if opcode == 0x70:
  write(HL, B)
\end{verbatim}
\end{description}

\subsection{LD (HL), n}
\label{inst:LD_hl_n}

Load to the absolute address specified by the 16-bit register HL, the immediate data \texttt{n}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00110110}/\hex{36} + \texttt{n}
  \item[Length]
    2 bytes
  \item[Duration]
    3 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{LD (HL), n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n} 8D{W: n} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{HL} ; [opacity=0.4] 8D{PC+2} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x36:
  n = read(PC++)
  write(HL, n)
\end{verbatim}
\end{description}

\subsection{LD A, (BC)}
\label{inst:LD_a_bc}

Load to the 8-bit A register, data from the absolute address specified by the 16-bit register BC.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00001010}/\hex{0A}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD A, (BC)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{BC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x0A:
  A = read(BC)
\end{verbatim}
\end{description}

\subsection{LD A, (DE)}
\label{inst:LD_a_de}

Load to the 8-bit A register, data from the absolute address specified by the 16-bit register DE.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00011010}/\hex{1A}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD A, (DE)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{DE} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x1A:
  A = read(DE)
\end{verbatim}
\end{description}

\subsection{LD (BC), a}
\label{inst:LD_bc_a}

Load to the absolute address specified by the 16-bit register BC, data from the 8-bit A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00000010}/\hex{02}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD (BC), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{BC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x02:
  write(BC, A)
\end{verbatim}
\end{description}

\subsection{LD (DE), a}
\label{inst:LD_de_a}

Load to the absolute address specified by the 16-bit register DE, data from the 8-bit A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00010010}/\hex{12}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD (DE), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{DE} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x12:
  write(DE, A)
\end{verbatim}
\end{description}

\subsection{LD A, (nn)}
\label{inst:LD_a_nn}

Load to the 8-bit A register, data from the absolute address specified by the 16-bit operand \texttt{nn}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11111010}/\hex{FA} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{LD A, (nn)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8D{R: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8D{nn} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xFA:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  A = read(nn)
\end{verbatim}
\end{description}

\subsection{LD (nn), A}
\label{inst:LD_nn_a}

Load to the absolute address specified by the 16-bit operand \texttt{nn}, data from the 8-bit A register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11101010}/\hex{EA} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{LD (nn), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8D{W: data} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8D{nn} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xFA:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  write(nn, A)
\end{verbatim}
\end{description}

\subsection{LDH A, (C)}
\label{inst:LDH_a_c}

Load to the 8-bit A register, data from the address specified by the 8-bit C
register. The full 16-bit absolute address is obtained by setting the most
significant byte to \hex{FF} and the least significant byte to the value of C,
so the possible range is \hexrange{FF00}{FFFF}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11110010}/\hex{F2}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LDH A, (C)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{0xFF00+C} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xF2:
  A = read(unsigned_16(lsb=C, msb=0xFF))
\end{verbatim}
\end{description}

\subsection{LDH (C), A}
\label{inst:LDH_c_a}

Load to the address specified by the 8-bit C register, data from the 8-bit A
register. The full 16-bit absolute address is obtained by setting the most
significant byte to \hex{FF} and the least significant byte to the value of C,
so the possible range is \hexrange{FF00}{FFFF}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11100010}/\hex{E2}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LDH (C), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{0xFF00+C} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xE2:
  write(unsigned_16(lsb=C, msb=0xFF), A)
\end{verbatim}
\end{description}

\subsection{LDH A, (n)}
\label{inst:LDH_a_n}

Load to the 8-bit A register, data from the address specified by the 8-bit
immediate data \texttt{n}. The full 16-bit absolute address is obtained by
setting the most significant byte to \hex{FF} and the least significant byte to
the value of \texttt{n}, so the possible range is \hexrange{FF00}{FFFF}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11110000}/\hex{F0}
  \item[Length]
    2 bytes
  \item[Duration]
    3 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{LD A, (C)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n} 8D{R: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{0xFF00+n} ; [opacity=0.4] 8D{PC+2} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xF0:
  n = read(PC++)
  A = read(unsigned_16(lsb=n, msb=0xFF))
\end{verbatim}
\end{description}

\subsection{LDH (n), A}
\label{inst:LDH_n_a}

Load to the address specified by the 8-bit immediate data \texttt{n}, data from
the 8-bit A register. The full 16-bit absolute address is obtained by setting
the most significant byte to \hex{FF} and the least significant byte to the
value of \texttt{n}, so the possible range is \hexrange{FF00}{FFFF}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11100000}/\hex{E0}
  \item[Length]
    2 bytes
  \item[Duration]
    3 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{LDH (n), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: n} 8D{W: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{0xFF00+n} ; [opacity=0.4] 8D{PC+2} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xE0:
  n = read(PC++)
  write(unsigned_16(lsb=n, msb=0xFF), A)
\end{verbatim}
\end{description}

\subsection{LD A, (HL-)}
\label{inst:LD_a_hld}

Load to the 8-bit A register, data from the absolute address specified by the
16-bit register HL. The value of HL is decremented after the memory read.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00111010}/\hex{3A}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD A, (HL-)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x3A:
  A = read(HL--)
\end{verbatim}
\end{description}

\subsection{LD (HL-), A}
\label{inst:LD_hld_a}

Load to the absolute address specified by the 16-bit register HL, data from the
8-bit A register. The value of HL is decremented after the memory write.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00110010}/\hex{32}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD (HL-), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x32:
  write(HL--, A)
\end{verbatim}
\end{description}

\subsection{LD A, (HL+)}
\label{inst:LD_a_hli}

Load to the 8-bit A register, data from the absolute address specified by the
16-bit register HL. The value of HL is incremented after the memory read.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00101010}/\hex{2A}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD A, (HL+)} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x2A:
  A = read(HL++)
\end{verbatim}
\end{description}

\subsection{LD (HL+), A}
\label{inst:LD_hli_a}

Load to the absolute address specified by the 16-bit register HL, data from the
8-bit A register. The value of HL is incremented after the memory write.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00100010}/\hex{22}
  \item[Length]
    1 bytes
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD (HL+), A} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{W: A} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{HL} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x22:
  write(HL++, A)
\end{verbatim}
\end{description}

\section{16-bit load instructions}

16-bit load instructions transfer two bytes of data between two 16-bit
registers, or between one 16-bit register and two sequential locations in
memory.

\subsection{LD rr, nn}
\label{inst:LD_rr_nn}

Load to the 16-bit register \texttt{rr}, the immediate 16-bit data \texttt{nn}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00xx0001}/various + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 byte
  \item[Duration]
    3 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{LD rr, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: LD BC, nn
if opcode == 0x01:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  BC = nn
\end{verbatim}
\end{description}

\subsection{LD (nn), SP}
\label{inst:LD_nn_sp}

Load to the absolute address specified by the 16-bit operand \texttt{nn}, data from the 16-bit SP register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00001000}/\hex{08} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 byte
  \item[Duration]
    5 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5} 8D{M6/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 40D{LD (nn), SP} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8D{W: lsb(SP)} 8D{W: msb(SP)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8D{nn} 8D{nn+1} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x08:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  write(nn, lsb(SP))
  write(nn+1, msb(SP))
\end{verbatim}
\end{description}

\subsection{LD SP, HL}
\label{inst:LD_sp_hl}

Load to the 16-bit SP register, data from the 16-bit HL register.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11111001}/\hex{F9}
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{LD SP, HL} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8U ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xF9:
  SP = HL
\end{verbatim}
\end{description}

\subsection{PUSH rr}
\label{inst:PUSH_rr}

Push to the stack memory, data from the 16-bit register \texttt{rr}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11xx0101}/various
  \item[Length]
    1 byte
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{PUSH rr} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U 8D{W: msb(rr)} 8D{W: lsb(rr)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP-1} 8D{SP-2} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: PUSH BC
if opcode == 0xC5:
  SP--
  write(SP--, msb(BC))
  write(SP--, lsb(BC))
\end{verbatim}
\end{description}

\subsection{POP rr}
\label{inst:POP_rr}

Pops to the 16-bit register \texttt{rr}, data from the stack memory.

This instruction does not do calculations that affect flags, but POP AF
completely replaces the F register value, so all flags are changed based on the
8-bit data that is read from memory.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11xx0001}/various
  \item[Length]
    1 byte
  \item[Duration]
    3 machine cycles
  \item[Flags]
    see the instruction description
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{POP rr} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(rr)} 8D{R: msb(rr)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP+1} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
# example: POP BC
if opcode == 0xC1:
  BC = unsigned_16(lsb=read(SP++), msb=read(SP++))
\end{verbatim}
\end{description}

\section{8-bit arithmetic instructions}

\section{16-bit arithmetic instructions}

\section{Rotate, shift, and bit operation instructions}

\section{Control flow instructions}

\subsection{JP nn}
\label{inst:JP}

Unconditional jump to the absolute address specified by the 16-bit operand \texttt{nn}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{11000011}/\hex{C3} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{JP nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8U ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xC3:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  PC = nn
\end{verbatim}
\end{description}

\subsection{JP HL}
\label{inst:JP_hl}

Unconditional jump to the absolute address specified by the 16-bit register HL.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11101001}/\hex{E9}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{JP HL} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{HL} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xE9:
  PC = HL
\end{verbatim}
\end{description}

\begin{warning}
  In some documentation this instruction is written as \texttt{JP [HL]}. This
  is very misleading, since brackets are usually used to indicate a memory
  read, and this instruction simply copies the value of HL to PC.
\end{warning}

\subsection{JP cc, nn}
\label{inst:JP_cc}

Conditional jump to the absolute address specified by the 16-bit operand \texttt{nn}, depending on the condition \texttt{cc}.

Note that the operand (absolute address) is read even when the condition is false!

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{110cc010}/various + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    3 machine cycles (cc=false), or 4 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{JP cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{JP cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8U ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC2, 0xD2, 0xCA, 0xDA]:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  if F.check_condition(cc):
    PC = nn
\end{verbatim}
\end{description}

\subsection{JR e}
\label{inst:JR}

Unconditional jump to the relative address specified by the signed 8-bit operand \texttt{e}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{00011000}/\hex{18} + offset \texttt{e}
  \item[Length]
    2 bytes
  \item[Duration]
    3 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{JR e} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: e} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8U ; [opacity=0.4] 8D{PC+2+e} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x18:
  e = signed_8(read(PC++))
  PC = PC + e
\end{verbatim}
\end{description}

\subsection{JR cc, e}
\label{inst:JR_cc}

Conditional jump to the relative address specified by the signed 8-bit operand \texttt{e}, depending on the condition \texttt{cc}.

Note that the operand (relative address offset) is read even when the condition is false!

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{001cc000}/various + offset \texttt{e}
  \item[Length]
    2 bytes
  \item[Duration]
    2 machine cycles (cc=false), or 3 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{JR cc, e} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: e} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1}; [opacity=0.4] 8D{PC+2} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{JR cc, e} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: e} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8U ; [opacity=0.4] 8D{PC+2+e} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0x20, 0x30, 0x28, 0x38]:
  e = signed_8(read(PC++))
  if F.check_condition(cc):
    PC = PC + e
\end{verbatim}
\end{description}

\subsection{CALL nn}
\label{inst:CALL}

Unconditional function call to the absolute address specified by the 16-bit operand \texttt{nn}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{11001101}/\hex{CD} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    6 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5} 8D{M6} 8D{M7/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 48D{CALL nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U 8D{W: msb(PC+3)} 8D{W: lsb(PC+3)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8D{SP} 8D{SP-1} 8D{SP-2} ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xCD:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  write(--SP, msb(PC))
  write(--SP, lsb(PC))
  PC = nn
\end{verbatim}
\end{description}

\subsection{CALL cc, nn}
\label{inst:CALL_cc}

Conditional function call to the absolute address specified by the 16-bit operand \texttt{nn}, depending on the condition \texttt{cc}.

Note that the operand (absolute address) is read even when the condition is false!

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{110cc100}/various + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    3 machine cycles (cc=false), or 6 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{CALL cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5} 8D{M6} 8D{M7/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 48D{CALL cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U 8D{W: msb(PC+3)} 8D{W: lsb(PC+3)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8D{SP} 8D{SP-1} 8D{SP-2} ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC4, 0xD4, 0xCC, 0xDC]:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  if F.check_condition(cc):
    write(--SP, msb(PC))
    write(--SP, lsb(PC))
    PC = nn
\end{verbatim}
\end{description}

\subsection{RET}
\label{inst:RET}

Unconditional return from a function.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11001001}/\hex{C9}
  \item[Length]
    1 byte
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{RET} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(PC)} 8D{R: msb(PC)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP+1} 8U ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xC9:
  PC = unsigned_16(lsb=read(SP++), msb=read(SP++))
\end{verbatim}
\end{description}

\subsection{RET cc}
\label{inst:RET_cc}

Conditional return from a function, depending on the condition \texttt{cc}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{110cc000}/various
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles (cc=false), or 5 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{RET cc} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8U ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5} 8D{M6/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 40D{RET cc} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U 8D{R: lsb(PC)} 8D{R: msb(PC)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8U 8D{SP} 8D{SP+1} 8U ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC0, 0xD0, 0xC8, 0xD8]:
  if F.check_condition(cc):
    PC = unsigned_16(lsb=read(SP++), msb=read(SP++))
\end{verbatim}
\end{description}

\subsection{RETI}
\label{inst:RETI}

Unconditional return from a function. Also enables interrupts by setting IME=1.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11011001}/\hex{D9}
  \item[Length]
    1 byte
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{RETI} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(PC)} 8D{R: msb(PC)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP+1} 8U ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xD9:
  PC = unsigned_16(lsb=read(SP++), msb=read(SP++))
  IME = 1
\end{verbatim}
\end{description}

\subsection{RST n}
\label{inst:RST}

Unconditional function call to the absolute fixed address defined by the opcode.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11xxx111}/various
  \item[Length]
    1 byte
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{RST n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U 8D{W: msb(PC+1)} 8D{W: lsb(PC+1)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP-1} 8D{SP-2} ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC7, 0xD7, 0xE7, 0xF7, 0xCF, 0xDF, 0xEF, 0xFF]:
  n = rst_address(opcode)
  write(--SP, msb(PC))
  write(--SP, lsb(PC))
  PC = unsigned_16(lsb=n, msb=0x00)
\end{verbatim}
\end{description}

\section{Miscellaneous instructions}

\subsection{HALT}
\label{inst:HALT}

\subsection{STOP}
\label{inst:STOP}

\subsection{DI}
\label{inst:DI}

Disables interrupt handling by setting IME=0 and cancelling any scheduled
effects of the EI instruction if any.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11110011}/\hex{F3}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{DI} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xF3:
  IME = 0
\end{verbatim}
\end{description}

\subsection{EI}
\label{inst:EI}

Schedules interrupt handling to be enabled after the next machine cycle.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11111011}/\hex{FB}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle (+ 1 machine cycle for the effect)
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{EI} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xFB:
  IME_scheduled = true
\end{verbatim}
\end{description}

\subsection{CCF}
\label{inst:CCF}

Flips the carry flag, and clears the N and H flags.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00111111}/\hex{3F}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    N = 0, H = 0, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{CCF} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x3F:
  flags.N = 0
  flags.H = 0
  flags.C = ~flags.C
\end{verbatim}
\end{description}

\subsection{SCF}
\label{inst:SCF}

Sets the carry flag, and clears the N and H flags.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00110111}/\hex{37}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    N = 0, H = 0, C = 1
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{SCF} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x37:
  flags.N = 0
  flags.H = 0
  flags.C = 1
\end{verbatim}
\end{description}

\subsection{NOP}
\label{inst:NOP}

No-operation. This instruction doesn't do anything, but can be used to add a
delay of one machine cycle and increment PC by one.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00000000}/\hex{00}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{NOP} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x00:
  // nothing
\end{verbatim}
\end{description}

\subsection{DAA}
\label{inst:DAA}

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00100111}/\hex{27}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, H = 0, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{DAA} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\end{description}

\subsection{CPL}
\label{inst:CPL}

Flips all the bits in the 8-bit A register, and sets the N and H flags.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00101111}/\hex{2F}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    N = 1, H = 1
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{CPL} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x2F:
  A = ~A
  flags.N = 1
  flags.H = 1
\end{verbatim}
\end{description}

\end{document}
